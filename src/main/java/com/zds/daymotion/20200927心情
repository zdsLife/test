


学不完的知识
记不完的技巧

面试之前
比较让人难受的知识

jvm java 的虚拟机 可以跨多个平台运行

jmm java 的内层模型 这里面 需要看

我自己的思量  共享堆 对应代码的 类变量  私有栈 线程对象持有的栈
比如一个客服端的请求 过来 会对应调用 某一个接口
加入 这个接口的业务层代码 如果 依赖 多个其他服务里面的方法 这个时候
这个线程栈里面压入的方法栈帧 会随着这个方法的 不断的深入的调用
一直会想这个线程栈的栈顶不断压入被调用的方法

分代思想    因为你代码里面的对象 他们被其他对象依赖的时间不一样需要这样的分代设计

年轻代 老年代  永久代

对于这几个代 分别会采用什么样的垃圾回收器    及具体采用的组合几个垃圾回收器

回收垃圾释放无用的内存

标记清除  因为涉及到清理多了会有碎片 所以采用清理活得比较久数量比较少的老年代
复制清楚  因为涉及到多用一半空间    所以采用清理活得短较短数量比较少的年轻代










关于修饰符 public deafult protected private
公共 范围最大 面向对象的角度考虑


保护 protected 这个是父子类里面有使用





类的加载与spring 里面控制反转 里面对于你定义好的bean的注入添加
及当你的应用的某一个接口被调用 里面涉及到被注入到spring 容器里面的bean对象 被取出 get 读取
及这个类使用完 这个类被销毁 的删除方法 如果使用过程中对这个bean 对象有修改
如何人工修改这个bean 是否需要重新spring 预留的接口




一个变化 带来的复杂度的增加和便利的提高

单机 到微服务

熵的理论 随着量的增加更加复杂



对于spring的理解

先讲一下自己想到的前置知识
类的加载 类加载器 XMLReader        以reader结尾的读取接口 类路径classpath下编译好的.class文件
类的定义 beanDefinition   以Definition结尾的定义接口
类的其他部分的补充          bean的增强 以process 结尾的接口
类的实例化ClassForName     create 反射根据读取的.class结尾的字节码
addBean注册
注册到哪儿？
多个对象的存储 并发的集合容器 concurrentHashMap
实例化的对象使用getBean
对象使用完销毁disposableBean delete
（解耦） 通过动态代理类（代理设计模式）相当于对于一个方法的流程的某一个横截面加入了一个操作
多个写操作产生的事务  对与一个存在事务的方法
会在这个方法的几个写操作之前会开启事务
会在这个方法的几个写操作之后会提交事务
类似的
对于在业务类里面的方法开始加日志
对于在业务类里面的方法返回加日志
通常如果你想用一个对象非静态的方法需要把这个对象 通过new 关键字 创建出来
但是难免一个方法里面 会涉及多个对象的方法调用
这个时候 一旦随着你类的增加  会有多个类的实例需要手动创建
但是spring的ioc 就和好的把原来有程序员手动编码创建对象的过程控制权 交给了spring容器
所以产生了控制反转 对于依赖注入 这个也是交由spring 容器按需动态的把依赖的实例对象取出
对于AOP 面向切面编程 个人理解  为了解耦 利用动态代理类 动态的按需切入需要的代码片段
如 spring 里面 对于这个知识的运用 如日志的处理 和事务的处理




