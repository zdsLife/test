


为什么要有锁

因为因为并发 触及到一个临界区 共享值的写操作
脑中抽象  一把剑 箭头是共享的数据 剑的两个刃是平行的两个并发线程


都是并发读产生的问题


首相你想先能够 产生一个二维坐标

从上向下 并行两个事务

前提读同一个表的同一行数据 一个事务读到的是另一个事务没有真正落库的数据
（就是你读的确实是别人修改的值 但是这个值最终没有落库
就是另一个事务可能执行了回滚操作） 所以产生了脏读



不可重复度 很明显是一个事务读取共享读的这一行数据读了两次 但是发现读取的数据不一样

幻读 更侧重 相同条件下读了多条数据 结果发现有增又减 但是数据库中不一定真正有这个数据

说白了 两个事务对于共性行的数据读 没有隔离所以产生了一系列读的问题


既然是原子操作 那肯定是要有多个步骤的 所以这是需要细节到

连个事务线程 并行 对比每一个线程



用框架的目的 很大的原因就是为了解耦

















spring（数据库）事务隔离级别分为四种（级别递减）：
1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；

2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。

3、READ COMMITTED （提交读）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。

4、Read Uncommitted（未提交读） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。

脏读、不可重复读、幻读：
也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：

脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。

也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。

也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。

也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。

不可重复读和幻读比较：
两者有些相似，但是前者针对的是update或delete，后者针对的insert。








